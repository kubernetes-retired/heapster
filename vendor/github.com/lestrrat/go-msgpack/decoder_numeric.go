package msgpack

// Auto-generated by internal/cmd/gendecoder-numeric/gendecoder-numeric.go. DO NOT EDIT!

import (
	"math"

	"github.com/pkg/errors"
)

func (d *Decoder) DecodeInt(v *int) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Int64`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = int(code)
		return nil
	}

	if code != Int64.Byte() {
		return errors.Errorf(`msgpack: expected Int64, got %s`, Code(code))
	}
	x, err := d.src.ReadUint64()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for int`)
	}

	*v = int(x)
	return nil
}

func (d *Decoder) DecodeInt8(v *int8) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Int8`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = int8(code)
		return nil
	}

	if code != Int8.Byte() {
		return errors.Errorf(`msgpack: expected Int8, got %s`, Code(code))
	}
	x, err := d.src.ReadUint8()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for int8`)
	}

	*v = int8(x)
	return nil
}

func (d *Decoder) DecodeInt16(v *int16) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Int16`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = int16(code)
		return nil
	}

	if code != Int16.Byte() {
		return errors.Errorf(`msgpack: expected Int16, got %s`, Code(code))
	}
	x, err := d.src.ReadUint16()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for int16`)
	}

	*v = int16(x)
	return nil
}

func (d *Decoder) DecodeInt32(v *int32) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Int32`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = int32(code)
		return nil
	}

	if code != Int32.Byte() {
		return errors.Errorf(`msgpack: expected Int32, got %s`, Code(code))
	}
	x, err := d.src.ReadUint32()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for int32`)
	}

	*v = int32(x)
	return nil
}

func (d *Decoder) DecodeInt64(v *int64) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Int64`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = int64(code)
		return nil
	}

	if code != Int64.Byte() {
		return errors.Errorf(`msgpack: expected Int64, got %s`, Code(code))
	}
	x, err := d.src.ReadUint64()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for int64`)
	}

	*v = int64(x)
	return nil
}

func (d *Decoder) DecodeUint(v *uint) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Uint64`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = uint(code)
		return nil
	}

	if code != Uint64.Byte() {
		return errors.Errorf(`msgpack: expected Uint64, got %s`, Code(code))
	}
	x, err := d.src.ReadUint64()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for uint`)
	}

	*v = uint(x)
	return nil
}

func (d *Decoder) DecodeUint8(v *uint8) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Uint8`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = uint8(code)
		return nil
	}

	if code != Uint8.Byte() {
		return errors.Errorf(`msgpack: expected Uint8, got %s`, Code(code))
	}
	x, err := d.src.ReadUint8()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for uint8`)
	}

	*v = x
	return nil
}

func (d *Decoder) DecodeUint16(v *uint16) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Uint16`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = uint16(code)
		return nil
	}

	if code != Uint16.Byte() {
		return errors.Errorf(`msgpack: expected Uint16, got %s`, Code(code))
	}
	x, err := d.src.ReadUint16()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for uint16`)
	}

	*v = x
	return nil
}

func (d *Decoder) DecodeUint32(v *uint32) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Uint32`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = uint32(code)
		return nil
	}

	if code != Uint32.Byte() {
		return errors.Errorf(`msgpack: expected Uint32, got %s`, Code(code))
	}
	x, err := d.src.ReadUint32()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for uint32`)
	}

	*v = x
	return nil
}

func (d *Decoder) DecodeUint64(v *uint64) error {
	code, err := d.src.ReadByte()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read code for Uint64`)
	}
	if IsFixNumFamily(Code(code)) {
		*v = uint64(code)
		return nil
	}

	if code != Uint64.Byte() {
		return errors.Errorf(`msgpack: expected Uint64, got %s`, Code(code))
	}
	x, err := d.src.ReadUint64()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read payload for uint64`)
	}

	*v = x
	return nil
}

func (d *Decoder) DecodeFloat32(v *float32) error {
	code, x, err := d.src.ReadByteUint32()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read float32`)
	}

	if code != Float.Byte() {
		return errors.Errorf(`msgpack: expected Float, got %s`, Code(code))
	}

	*v = math.Float32frombits(x)
	return nil
}

func (d *Decoder) DecodeFloat64(v *float64) error {
	code, x, err := d.src.ReadByteUint64()
	if err != nil {
		return errors.Wrap(err, `msgpack: failed to read float64`)
	}

	if code != Double.Byte() {
		return errors.Errorf(`msgpack: expected Double, got %s`, Code(code))
	}

	*v = math.Float64frombits(x)
	return nil
}
